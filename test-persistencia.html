<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§ª Test de Persistencia de Progreso</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            padding: 20px; 
            background: #1a1a1a; 
            color: #e5e5e5;
            max-width: 800px;
            margin: 0 auto;
        }
        .test-section { 
            background: #2d2d2d; 
            padding: 20px; 
            margin: 15px 0; 
            border-radius: 8px; 
            border-left: 4px solid #4CAF50;
        }
        .test-section.warning { border-left-color: #FF9800; }
        .test-section.error { border-left-color: #f44336; }
        button { 
            background: #4CAF50; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 6px; 
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        pre { 
            background: #1e1e1e; 
            padding: 15px; 
            border-radius: 6px; 
            overflow-x: auto;
            font-size: 12px;
        }
        .status { 
            padding: 10px; 
            border-radius: 6px; 
            margin: 10px 0;
        }
        .success { background: rgba(76, 175, 80, 0.2); color: #4CAF50; }
        .error { background: rgba(244, 67, 54, 0.2); color: #f44336; }
        .info { background: rgba(33, 150, 243, 0.2); color: #2196F3; }
        h2 { color: #4CAF50; }
    </style>
</head>
<body>
    <h1>ğŸ§ª Test de Persistencia Completa del Sistema de Progreso</h1>
    
    <div class="test-section">
        <h2>ğŸ“‹ Plan de Pruebas</h2>
        <ol>
            <li><strong>Verificar userId persistente:</strong> localStorage debe mantener el mismo ID</li>
            <li><strong>Simular prÃ¡ctica:</strong> Crear intentos y datos de mastery</li>
            <li><strong>Verificar IndexedDB:</strong> Los datos deben guardarse por userId</li>
            <li><strong>Simular reinicio:</strong> Limpiar memoria, mantener storage</li>
            <li><strong>Recuperar datos:</strong> Verificar que se cargan los datos anteriores</li>
            <li><strong>Acumular mÃ¡s datos:</strong> Nuevos intentos se suman a los existentes</li>
        </ol>
    </div>

    <div class="test-section">
        <h2>ğŸ”‘ Estado del Sistema</h2>
        <div id="system-status">Inicializando...</div>
        <button onclick="checkSystemStatus()">ğŸ”„ Verificar Estado</button>
        <button onclick="clearAllData()">ğŸ—‘ï¸ Limpiar Todo</button>
    </div>

    <div class="test-section">
        <h2>ğŸ‘¤ GestiÃ³n de Usuario</h2>
        <div id="user-status">Verificando usuario...</div>
        <button onclick="showUserInfo()">ğŸ‘¤ Info Usuario</button>
        <button onclick="simulateRestart()">ğŸ”„ Simular Reinicio App</button>
    </div>

    <div class="test-section">
        <h2>ğŸ“š SimulaciÃ³n de PrÃ¡ctica</h2>
        <div id="practice-status">Listo para practicar...</div>
        <button onclick="simulatePractice()">ğŸ¯ Simular 3 Intentos</button>
        <button onclick="showProgressData()">ğŸ“Š Ver Datos Acumulados</button>
    </div>

    <div class="test-section">
        <h2>ğŸ’¾ VerificaciÃ³n de Persistencia</h2>
        <div id="persistence-status">Sin verificar...</div>
        <button onclick="testPersistence()">ğŸ§ª Test Completo de Persistencia</button>
    </div>

    <div class="test-section">
        <h2>ğŸ“Š Logs y Resultados</h2>
        <pre id="logs">Logs aparecerÃ¡n aquÃ­...\n</pre>
        <button onclick="clearLogs()">ğŸ§¹ Limpiar Logs</button>
    </div>

    <script type="module">
        // Importar mÃ³dulos necesarios
        import { initProgressSystem, getCurrentUserId, resetProgressSystem } from './src/lib/progress/index.js'
        import { trackAttemptStarted, trackAttemptSubmitted, initTracking } from './src/lib/progress/tracking.js'
        import { getAttemptsByUser, getMasteryByUser, getAllFromDB } from './src/lib/progress/database.js'

        let systemInitialized = false;
        let currentTestUserId = null;

        // FunciÃ³n para logging
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('logs');
            const color = type === 'error' ? '#f44336' : type === 'success' ? '#4CAF50' : '#2196F3';
            logElement.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}</span>\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        // Funciones globales para los botones
        window.clearLogs = () => {
            document.getElementById('logs').innerHTML = 'Logs limpiados...\n';
        }

        window.checkSystemStatus = async () => {
            try {
                log('ğŸ” Verificando estado del sistema...', 'info');
                
                // Verificar localStorage
                const storedUserId = localStorage.getItem('progress-system-user-id');
                log(`ğŸ“± userId en localStorage: ${storedUserId || 'NO ENCONTRADO'}`, storedUserId ? 'success' : 'error');
                
                // Verificar sistema de progreso
                if (!systemInitialized) {
                    currentTestUserId = await initProgressSystem();
                    systemInitialized = true;
                    log(`âœ… Sistema inicializado con userId: ${currentTestUserId}`, 'success');
                } else {
                    log(`âœ… Sistema ya inicializado con userId: ${currentTestUserId}`, 'info');
                }

                // Verificar IndexedDB
                const stores = ['users', 'attempts', 'mastery', 'schedules'];
                for (const store of stores) {
                    try {
                        const data = await getAllFromDB(store);
                        log(`ğŸ“Š ${store}: ${data.length} registros`, 'info');
                    } catch (e) {
                        log(`âŒ Error accediendo ${store}: ${e.message}`, 'error');
                    }
                }

                document.getElementById('system-status').innerHTML = `
                    <div class="success">âœ… Sistema operativo</div>
                    <div class="info">ğŸ†” Usuario actual: ${currentTestUserId}</div>
                    <div class="info">ğŸ’¾ localStorage: ${storedUserId ? 'OK' : 'FALTANTE'}</div>
                `;

            } catch (error) {
                log(`âŒ Error verificando sistema: ${error.message}`, 'error');
                document.getElementById('system-status').innerHTML = `<div class="error">âŒ Error: ${error.message}</div>`;
            }
        }

        window.showUserInfo = async () => {
            try {
                const userId = getCurrentUserId();
                log(`ğŸ‘¤ getCurrentUserId() retorna: ${userId}`, userId ? 'success' : 'error');
                
                const storedUserId = localStorage.getItem('progress-system-user-id');
                log(`ğŸ“± localStorage userId: ${storedUserId}`, storedUserId ? 'success' : 'error');
                
                const match = userId === storedUserId;
                log(`ğŸ”„ Â¿Coinciden?: ${match ? 'SÃ' : 'NO'}`, match ? 'success' : 'error');

                document.getElementById('user-status').innerHTML = `
                    <div class="${userId ? 'success' : 'error'}">ğŸ†” Usuario actual: ${userId || 'NO ENCONTRADO'}</div>
                    <div class="${storedUserId ? 'success' : 'error'}">ğŸ’¾ Usuario persistente: ${storedUserId || 'NO GUARDADO'}</div>
                    <div class="${match ? 'success' : 'error'}">ğŸ”„ SincronizaciÃ³n: ${match ? 'OK' : 'DESINCRONIZADO'}</div>
                `;
            } catch (error) {
                log(`âŒ Error obteniendo info de usuario: ${error.message}`, 'error');
            }
        }

        window.simulateRestart = async () => {
            try {
                log('ğŸ”„ SIMULANDO REINICIO DE APLICACIÃ“N...', 'info');
                log('ğŸ“± Manteniendo localStorage (como en reinicio real)', 'info');
                log('ğŸ§  Limpiando estado de memoria...', 'info');
                
                // Resetear variables de memoria sin tocar localStorage/IndexedDB
                systemInitialized = false;
                const previousUserId = currentTestUserId;
                currentTestUserId = null;
                
                log('ğŸ’¤ Esperando 1 segundo para simular carga...', 'info');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                log('ğŸš€ Reinicializando sistema...', 'info');
                currentTestUserId = await initProgressSystem();
                systemInitialized = true;
                
                const recovered = currentTestUserId === previousUserId;
                log(`ğŸ¯ Usuario anterior: ${previousUserId}`, 'info');
                log(`ğŸ¯ Usuario recuperado: ${currentTestUserId}`, 'info');
                log(`âœ… Â¿RecuperaciÃ³n exitosa?: ${recovered ? 'SÃ' : 'NO'}`, recovered ? 'success' : 'error');
                
                if (recovered) {
                    log('ğŸ‰ Â¡PERSISTENCIA EXITOSA! El usuario se recuperÃ³ correctamente.', 'success');
                } else {
                    log('ğŸ’¥ Â¡FALLO DE PERSISTENCIA! Se creÃ³ un usuario diferente.', 'error');
                }

            } catch (error) {
                log(`âŒ Error en simulaciÃ³n de reinicio: ${error.message}`, 'error');
            }
        }

        window.simulatePractice = async () => {
            try {
                if (!systemInitialized) {
                    await checkSystemStatus();
                }

                log('ğŸ¯ Iniciando simulaciÃ³n de prÃ¡ctica...', 'info');
                
                // Simular 3 intentos diferentes
                const attempts = [
                    { verb: 'ser', mood: 'indicative', tense: 'pres', person: 'yo', correct: true, answer: 'soy' },
                    { verb: 'hacer', mood: 'indicative', tense: 'pretIndef', person: 'tÃº', correct: false, answer: 'haciste' },
                    { verb: 'tener', mood: 'subjunctive', tense: 'subjPres', person: 'Ã©l', correct: true, answer: 'tenga' }
                ];

                for (let i = 0; i < attempts.length; i++) {
                    const attempt = attempts[i];
                    log(`ğŸ“ Procesando intento ${i + 1}: ${attempt.verb} (${attempt.mood}/${attempt.tense}/${attempt.person})`, 'info');
                    
                    const testItem = {
                        id: `test-${attempt.verb}-${Date.now()}-${i}`,
                        lemma: attempt.verb,
                        mood: attempt.mood,
                        tense: attempt.tense,
                        person: attempt.person,
                        value: attempt.answer
                    };

                    const attemptId = trackAttemptStarted(testItem);
                    await trackAttemptSubmitted(attemptId, {
                        correct: attempt.correct,
                        latencyMs: 1500 + (Math.random() * 1000),
                        hintsUsed: 0,
                        errorTags: attempt.correct ? [] : ['conjugation'],
                        userAnswer: attempt.answer,
                        correctAnswer: attempt.answer,
                        item: testItem
                    });
                    
                    log(`âœ… Intento ${i + 1} guardado: ${attempt.correct ? 'CORRECTO' : 'INCORRECTO'}`, attempt.correct ? 'success' : 'error');
                }

                log('ğŸ¯ Â¡PrÃ¡ctica simulada completada!', 'success');
                document.getElementById('practice-status').innerHTML = '<div class="success">âœ… 3 intentos simulados guardados</div>';

            } catch (error) {
                log(`âŒ Error en simulaciÃ³n de prÃ¡ctica: ${error.message}`, 'error');
                document.getElementById('practice-status').innerHTML = `<div class="error">âŒ Error: ${error.message}</div>`;
            }
        }

        window.showProgressData = async () => {
            try {
                if (!currentTestUserId) {
                    log('âŒ No hay usuario inicializado', 'error');
                    return;
                }

                log('ğŸ“Š Cargando datos de progreso...', 'info');
                
                const attempts = await getAttemptsByUser(currentTestUserId);
                const mastery = await getMasteryByUser(currentTestUserId);
                
                log(`ğŸ“ˆ Total de intentos: ${attempts.length}`, 'info');
                log(`ğŸ“Š Registros de mastery: ${mastery.length}`, 'info');

                if (attempts.length > 0) {
                    log('ğŸ“ Ãšltimos intentos:', 'info');
                    attempts.slice(-3).forEach((attempt, index) => {
                        log(`  ${index + 1}. ${attempt.mood}/${attempt.tense}/${attempt.person} - ${attempt.correct ? 'âœ…' : 'âŒ'} (${new Date(attempt.createdAt).toLocaleTimeString()})`, 'info');
                    });
                }

                if (mastery.length > 0) {
                    log('ğŸ† Mastery por celda:', 'info');
                    mastery.forEach(m => {
                        log(`  ${m.mood}/${m.tense}/${m.person}: ${m.score.toFixed(1)}%`, 'info');
                    });
                }

            } catch (error) {
                log(`âŒ Error mostrando datos: ${error.message}`, 'error');
            }
        }

        window.testPersistence = async () => {
            try {
                log('ğŸ§ª INICIANDO TEST COMPLETO DE PERSISTENCIA...', 'info');
                log('=' + '='.repeat(50), 'info');
                
                // Paso 1: Limpiar todo
                log('ğŸ§¹ PASO 1: Limpiando datos existentes...', 'info');
                await resetProgressSystem();
                
                // Paso 2: Primera inicializaciÃ³n
                log('ğŸš€ PASO 2: Primera inicializaciÃ³n...', 'info');
                const firstUserId = await initProgressSystem();
                log(`ğŸ‘¤ Primer usuario creado: ${firstUserId}`, 'success');
                
                // Paso 3: Simular prÃ¡ctica
                log('ğŸ¯ PASO 3: Simulando prÃ¡ctica inicial...', 'info');
                await simulatePractice();
                await new Promise(resolve => setTimeout(resolve, 500)); // Dar tiempo para guardar
                
                // Paso 4: Verificar datos iniciales
                const initialAttempts = await getAttemptsByUser(firstUserId);
                const initialMastery = await getMasteryByUser(firstUserId);
                log(`ğŸ“Š Datos iniciales: ${initialAttempts.length} intentos, ${initialMastery.length} mastery`, 'info');
                
                // Paso 5: Simular reinicio completo
                log('ğŸ”„ PASO 5: Simulando reinicio completo de aplicaciÃ³n...', 'info');
                systemInitialized = false;
                currentTestUserId = null;
                
                // Paso 6: Reinicializar y verificar recuperaciÃ³n
                log('ğŸ“± PASO 6: Reinicializando sistema...', 'info');
                const recoveredUserId = await initProgressSystem();
                systemInitialized = true;
                currentTestUserId = recoveredUserId;
                
                const userRecovered = recoveredUserId === firstUserId;
                log(`ğŸ” Usuario original: ${firstUserId}`, 'info');
                log(`ğŸ” Usuario recuperado: ${recoveredUserId}`, 'info');
                log(`ğŸ¯ Â¿Usuario recuperado?: ${userRecovered ? 'SÃ' : 'NO'}`, userRecovered ? 'success' : 'error');
                
                // Paso 7: Verificar datos recuperados
                const recoveredAttempts = await getAttemptsByUser(recoveredUserId);
                const recoveredMastery = await getMasteryByUser(recoveredUserId);
                
                const dataRecovered = recoveredAttempts.length === initialAttempts.length;
                log(`ğŸ“Š Intentos originales: ${initialAttempts.length}`, 'info');
                log(`ğŸ“Š Intentos recuperados: ${recoveredAttempts.length}`, 'info');
                log(`ğŸ¯ Â¿Datos recuperados?: ${dataRecovered ? 'SÃ' : 'NO'}`, dataRecovered ? 'success' : 'error');
                
                // Paso 8: AÃ±adir mÃ¡s datos y verificar acumulaciÃ³n
                log('â• PASO 8: AÃ±adiendo mÃ¡s prÃ¡ctica para probar acumulaciÃ³n...', 'info');
                await simulatePractice();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const finalAttempts = await getAttemptsByUser(recoveredUserId);
                const dataAccumulated = finalAttempts.length > recoveredAttempts.length;
                log(`ğŸ“Š Intentos tras nueva prÃ¡ctica: ${finalAttempts.length}`, 'info');
                log(`ğŸ¯ Â¿Datos se acumulan?: ${dataAccumulated ? 'SÃ' : 'NO'}`, dataAccumulated ? 'success' : 'error');
                
                // Resultado final
                log('=' + '='.repeat(50), 'info');
                const allTestsPassed = userRecovered && dataRecovered && dataAccumulated;
                
                if (allTestsPassed) {
                    log('ğŸ‰ Â¡TODOS LOS TESTS PASARON! PERSISTENCIA COMPLETAMENTE FUNCIONAL', 'success');
                    document.getElementById('persistence-status').innerHTML = '<div class="success">âœ… PERSISTENCIA VERIFICADA - TODO FUNCIONA CORRECTAMENTE</div>';
                } else {
                    log('ğŸ’¥ ALGUNOS TESTS FALLARON - HAY PROBLEMAS DE PERSISTENCIA', 'error');
                    document.getElementById('persistence-status').innerHTML = '<div class="error">âŒ PROBLEMAS DE PERSISTENCIA DETECTADOS</div>';
                }
                
                log(`ğŸ“‹ RESUMEN:`, 'info');
                log(`  - âœ… Usuario persiste: ${userRecovered ? 'SÃ' : 'NO'}`, userRecovered ? 'success' : 'error');
                log(`  - âœ… Datos se recuperan: ${dataRecovered ? 'SÃ' : 'NO'}`, dataRecovered ? 'success' : 'error');
                log(`  - âœ… Datos se acumulan: ${dataAccumulated ? 'SÃ' : 'NO'}`, dataAccumulated ? 'success' : 'error');
                
            } catch (error) {
                log(`ğŸ’¥ ERROR CRÃTICO EN TEST DE PERSISTENCIA: ${error.message}`, 'error');
                document.getElementById('persistence-status').innerHTML = `<div class="error">ğŸ’¥ Error crÃ­tico: ${error.message}</div>`;
            }
        }

        window.clearAllData = async () => {
            if (confirm('Â¿Seguro que quieres limpiar TODOS los datos? Esto no se puede deshacer.')) {
                try {
                    log('ğŸ—‘ï¸ Limpiando todos los datos...', 'info');
                    await resetProgressSystem();
                    systemInitialized = false;
                    currentTestUserId = null;
                    log('âœ… Todos los datos limpiados', 'success');
                    document.getElementById('system-status').innerHTML = '<div class="info">ğŸ§¹ Datos limpiados - Sistema reiniciado</div>';
                    document.getElementById('user-status').innerHTML = '<div class="info">ğŸ‘¤ Sin usuario - Listo para pruebas frescas</div>';
                    document.getElementById('practice-status').innerHTML = '<div class="info">ğŸ¯ Sin prÃ¡ctica - Listo para simular</div>';
                    document.getElementById('persistence-status').innerHTML = '<div class="info">ğŸ“ Sin verificar - Ejecuta test de persistencia</div>';
                } catch (error) {
                    log(`âŒ Error limpiando datos: ${error.message}`, 'error');
                }
            }
        }

        // Inicializar automÃ¡ticamente
        document.addEventListener('DOMContentLoaded', async () => {
            log('ğŸš€ PÃ¡gina de test cargada, inicializando verificaciones...', 'info');
            await checkSystemStatus();
            await showUserInfo();
        });

    </script>
</body>
</html>