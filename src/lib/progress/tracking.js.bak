// Sistema de tracking de eventos para el sistema de progreso

import { saveAttempt, saveMastery, saveSchedule } from './database.js'
import { calculateNextInterval, updateSchedule } from './srs.js'
import { calculateMasteryForItem } from './mastery.js'
import { ERROR_TAGS } from './dataModels.js'

// Estado del tracking
let currentSession = null
let currentUserId = null

/**
 * Inicializa el sistema de tracking
 * @param {string} userId - ID del usuario
 * @returns {Promise<void>}
 */
export async function initTracking(userId) {
  console.log(`üéØ Inicializando tracking para usuario ${userId}`)
  
  try {
    // Crear sesi√≥n actual
    currentSession = {
      id: `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      userId,
      startedAt: new Date(),
      endedAt: null
    }
    
    currentUserId = userId
    
    console.log(`‚úÖ Tracking inicializado para sesi√≥n ${currentSession.id}`)
  } catch (error) {
    console.error('‚ùå Error al inicializar el sistema de tracking:', error)
    throw error
  }
}

/**
 * Registra el inicio de un intento
 * @param {Object} item - √çtem que se va a practicar
 * @returns {string} ID del intento
 */
export function trackAttemptStarted(item) {
  if (!currentSession) {
    throw new Error('Sistema de tracking no inicializado')
  }
  
  const attemptId = `attempt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  
  console.log(`üéØ Intento iniciado: ${attemptId} para √≠tem ${item.id}`)
  return attemptId
}

/**
 * Registra la finalizaci√≥n de un intento
 * @param {string} attemptId - ID del intento
 * @param {Object} result - Resultado del intento
 * @returns {Promise<void>}
 */
export async function trackAttemptSubmitted(attemptId, result) {
  if (!currentSession) {
    throw new Error('Sistema de tracking no inicializado')
  }
  
  try {
    // Clasificar errores si es incorrecto
    let errorTags = []
    if (!result.correct && !result.isAccentError) {
      errorTags = classifyError(result.userAnswer, result.correctAnswer, result.item)
    }
    
    // Crear objeto de intento
    const attempt = {
      id: attemptId,
      userId: currentSession.userId,
      itemId: result.itemId,
      correct: result.correct,
      latencyMs: result.latencyMs,
      hintsUsed: result.hintsUsed || 0,
      errorTags,
      createdAt: new Date()
    }
    
    // Guardar intento en la base de datos
    await saveAttempt(attempt)
    
    console.log(`‚úÖ Intento registrado: ${attemptId}`, attempt)
  } catch (error) {
    console.error(`‚ùå Error al registrar intento ${attemptId}:`, error)
    throw error
  }
}

/**
 * Registra el final de una sesi√≥n
 * @param {Object} sessionData - Datos adicionales de la sesi√≥n
 * @returns {Promise<void>}
 */
export async function trackSessionEnded(sessionData = {}) {
  if (!currentSession) {
    throw new Error('Sistema de tracking no inicializado')
  }
  
  try {
    // Marcar fin de sesi√≥n
    currentSession.endedAt = new Date()
    
    console.log(`üîö Sesi√≥n finalizada: ${currentSession.id}`, sessionData)
  } catch (error) {
    console.error('‚ùå Error al finalizar sesi√≥n:', error)
    throw error
  }
}

/**
 * Registra que se mostr√≥ una pista
 * @returns {Promise<void>}
 */
export async function trackHintShown() {
  try {
    // En una implementaci√≥n completa, esto guardar√≠a el evento
    console.log('üí° Pista mostrada')
  } catch (error) {
    console.error('‚ùå Error al mostrar pista:', error)
    throw error
  }
}

/**
 * Registra que se increment√≥ una racha
 * @returns {Promise<void>}
 */
export async function trackStreakIncremented() {
  try {
    // En una implementaci√≥n completa, esto guardar√≠a el evento
    console.log('üî• Racha incrementada')
  } catch (error) {
    console.error('‚ùå Error al incrementar racha:', error)
    throw error
  }
}

/**
 * Registra el inicio de un drill de tiempo
 * @param {string} tense - Tiempo que se practica
 * @returns {Promise<void>}
 */
export async function trackTenseDrillStarted(tense) {
  try {
    // En una implementaci√≥n completa, esto guardar√≠a el evento
    console.log(`üîÅ Drill de tiempo ${tense} iniciado`)
  } catch (error) {
    console.error('‚ùå Error al iniciar drill de tiempo:', error)
    throw error
  }
}

/**
 * Registra el final de un drill de tiempo
 * @param {string} tense - Tiempo que se practicaba
 * @returns {Promise<void>}
 */
export async function trackTenseDrillEnded(tense) {
  try {
    // En una implementaci√≥n completa, esto guardar√≠a el evento
    console.log(`‚úÖ Drill de tiempo ${tense} finalizado`)
  } catch (error) {
    console.error('‚ùå Error al finalizar drill de tiempo:', error)
    throw error
  }
}

/**
 * Obtiene las estad√≠sticas actuales del usuario
 * @returns {Promise<Object>} Estad√≠sticas del usuario
 */
export async function getUserStats() {
  if (!currentUserId) {
    throw new Error('Sistema de tracking no inicializado')
  }
  
  try {
    // En una implementaci√≥n completa, esto calcular√≠a estad√≠sticas reales
    // basadas en los datos de la base de datos
    
    return {
      userId: currentUserId,
      totalAttempts: 0,
      correctAttempts: 0,
      currentStreak: 0,
      longestStreak: 0,
      lastActive: new Date()
    }
  } catch (error) {
    console.error('‚ùå Error al obtener estad√≠sticas del usuario:', error)
    throw error
  }
}

/**\n * Clasifica un error espec√≠fico\n * @param {string} userAnswer - Respuesta del usuario\n * @param {string} correctAnswer - Respuesta correcta\n * @param {Object} item - √çtem practicado\n * @returns {string[]} Etiquetas de error\n */\nexport function classifyError(userAnswer, correctAnswer, item) {\n  const errors = []\n  \n  // Normalizar las respuestas para comparaci√≥n\n  const normalizedUser = normalizeAnswer(userAnswer)\n  const normalizedCorrect = normalizeAnswer(correctAnswer)\n  \n  // Si las respuestas son id√©nticas, no hay error\n  if (normalizedUser === normalizedCorrect) {\n    return []\n  }\n  \n  // Verificar errores espec√≠ficos\n  \n  // 1. Persona equivocada\n  if (item.person && userAnswer && correctAnswer) {\n    // Extraer la persona de la respuesta correcta si est√° disponible\n    const correctPerson = item.person\n    \n    // Esta es una implementaci√≥n simplificada\n    // En la pr√°ctica, se necesitar√≠a un an√°lisis m√°s complejo\n    // Por ahora, marcamos como error de persona si hay diferencia\n    errors.push(ERROR_TAGS.WRONG_PERSON)\n  }\n  \n  // 2. Terminaci√≥n verbal\n  // Verificar si la ra√≠z es correcta pero la terminaci√≥n no\n  if (item.form && item.form.lemma) {\n    const lemma = item.form.lemma\n    // Verificar si la respuesta del usuario contiene la ra√≠z correcta\n    // pero tiene una terminaci√≥n incorrecta\n    if (normalizedUser && normalizedCorrect && \n        normalizedCorrect.startsWith(lemma.slice(0, -2)) && \n        !normalizedUser.startsWith(lemma.slice(0, -2))) {\n      errors.push(ERROR_TAGS.VERBAL_ENDING)\n    }\n  }\n  \n  // 3. Ra√≠z irregular\n  // Verificar si la terminaci√≥n es correcta pero la ra√≠z no\n  if (item.form && item.form.value) {\n    const correctEnding = normalizedCorrect.slice(-2)\n    const userEnding = normalizedUser.slice(-2)\n    \n    if (correctEnding === userEnding && normalizedUser !== normalizedCorrect) {\n      errors.push(ERROR_TAGS.IRREGULAR_STEM)\n    }\n  }\n  \n  // 4. Acentuaci√≥n\n  // Verificar si la diferencia es solo en acentuaci√≥n\n  if (normalizedUser.replace(/[\\u0300-\\u036f]/g, '') === \n      normalizedCorrect.replace(/[\\u0300-\\u036f]/g, '') && \n      normalizedUser !== normalizedCorrect) {\n    errors.push(ERROR_TAGS.ACCENT)\n  }\n  \n  // 5. Ortograf√≠a (g/gu, c/qu, z/c)\n  // Verificar errores comunes de ortograf√≠a\n  if (normalizedUser.replace(/gu/g, 'g') === normalizedCorrect ||\n      normalizedUser.replace(/g/g, 'gu') === normalizedCorrect ||\n      normalizedUser.replace(/qu/g, 'c') === normalizedCorrect ||\n      normalizedUser.replace(/c/g, 'qu') === normalizedCorrect ||\n      normalizedUser.replace(/z/g, 'c') === normalizedCorrect ||\n      normalizedUser.replace(/c/g, 'z') === normalizedCorrect) {\n    errors.push(ERROR_TAGS.ORTHOGRAPHY_G_GU)\n  }\n  \n  // Si no se identifican errores espec√≠ficos, marcar como error general\n  if (errors.length === 0) {\n    errors.push(ERROR_TAGS.WRONG_PERSON) // Por defecto\n  }\n  \n  return errors\n}

/**
 * Normaliza una respuesta para comparaci√≥n
 * @param {string} answer - Respuesta a normalizar
 * @returns {string} Respuesta normalizada
 */
function normalizeAnswer(answer) {
  if (!answer || typeof answer !== 'string') return ''
  
  return answer
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remover acentos
    .replace(/\s+/g, ' ') // Normalizar espacios
    .trim()
}